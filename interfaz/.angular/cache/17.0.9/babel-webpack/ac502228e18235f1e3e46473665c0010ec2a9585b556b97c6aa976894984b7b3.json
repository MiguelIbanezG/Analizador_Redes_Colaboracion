{"ast":null,"code":"import { DataSet } from 'vis';\nimport * as i0 from \"@angular/core\";\nexport class AppNetworkInitService {\n  constructor() {\n    this.nameAuthors = [];\n  }\n  getNodes() {\n    // Obtener al autor con más publicaciones\n    const authorWithMostPublications = this.nameAuthors.reduce((prev, current) => prev.publications.length > current.publications.length ? prev : current);\n    // Calcular la distancia de cada autor al autor principal\n    const distances = {};\n    this.nameAuthors.forEach(author => {\n      const distance = author === authorWithMostPublications ? 0 : 1 / author.publications.length;\n      distances[author.researcher] = distance;\n    });\n    // Obtener el valor máximo de distancia\n    const maxDistance = Math.max(...Object.values(distances));\n    // Mapear los nodos ajustando el tamaño en función de las publicaciones y la distancia al autor principal\n    const nodesData = this.nameAuthors.map(author => ({\n      id: author.researcher,\n      label: author.researcher,\n      value: author.publications.length * 10,\n      scaling: {\n        min: author.publications.length * 10,\n        max: author.publications.length * 15 // Ajuste el tamaño máximo según sea necesario\n      },\n\n      font: {\n        size: Math.floor(author.publications.length * 1.5),\n        color: \"#ffffff\"\n      },\n      color: {\n        background: \"rgb(0, 22, 68)\",\n        border: \"#000000\",\n        highlight: {\n          background: \"#00ff00\",\n          border: \"#000000\"\n        },\n        hover: {\n          background: \"#0000ff\",\n          border: \"#000000\"\n        }\n      },\n      x: author.researcher === authorWithMostPublications.researcher ? 0 : undefined,\n      y: author.researcher === authorWithMostPublications.researcher ? 0 : undefined,\n      level: author.researcher === authorWithMostPublications.researcher ? 0 : distances[author.researcher] / maxDistance // Calcular el nivel según la distancia\n    }));\n\n    const nodes = new DataSet(nodesData);\n    return nodes;\n  }\n  getEdges() {\n    // Ordenar los autores por el número de publicaciones en orden descendente\n    const sortedAuthors = this.nameAuthors.sort((a, b) => b.publications.length - a.publications.length);\n    // Tomar al primer autor de la lista, que será el autor con más publicaciones\n    const authorWithMostPublications = sortedAuthors[0];\n    // Generar aristas conectando al autor con más publicaciones con todos los demás autores\n    const edgesData = this.nameAuthors.filter(author => author.researcher !== authorWithMostPublications.researcher).map(author => ({\n      from: authorWithMostPublications.researcher,\n      to: author.researcher\n    }));\n    const edges = new DataSet(edgesData);\n    return edges;\n  }\n  static #_ = this.ɵfac = function AppNetworkInitService_Factory(t) {\n    return new (t || AppNetworkInitService)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AppNetworkInitService,\n    factory: AppNetworkInitService.ɵfac\n  });\n}","map":{"version":3,"names":["DataSet","AppNetworkInitService","constructor","nameAuthors","getNodes","authorWithMostPublications","reduce","prev","current","publications","length","distances","forEach","author","distance","researcher","maxDistance","Math","max","Object","values","nodesData","map","id","label","value","scaling","min","font","size","floor","color","background","border","highlight","hover","x","undefined","y","level","nodes","getEdges","sortedAuthors","sort","a","b","edgesData","filter","from","to","edges","_","_2","factory","ɵfac"],"sources":["/home/miguel/Analizador_Redes_Colaboracion/interfaz/src/app/services/network.init.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Network, DataSet, Options, Data, IdType, Edge } from 'vis';\nimport { Node } from '../models/network.model';\n@Injectable()\nexport class AppNetworkInitService {\n\n  public nameAuthors:any = [];\n\n  getNodes(): DataSet<Node> {\n    // Obtener al autor con más publicaciones\n    const authorWithMostPublications = this.nameAuthors.reduce((prev: any, current: any) => (prev.publications.length > current.publications.length) ? prev : current);\n\n    // Calcular la distancia de cada autor al autor principal\n    const distances: { [key: string]: number } = {};\n    this.nameAuthors.forEach((author: any) => {\n      const distance = author === authorWithMostPublications ? 0 : 1 / author.publications.length;\n      distances[author.researcher] = distance;\n    });\n\n    // Obtener el valor máximo de distancia\n    const maxDistance = Math.max(...Object.values(distances));\n\n    // Mapear los nodos ajustando el tamaño en función de las publicaciones y la distancia al autor principal\n    const nodesData: Node[] = this.nameAuthors.map((author: any) => ({\n      id: author.researcher,\n      label: author.researcher,\n      value: author.publications.length * 10, // Ajuste el factor multiplicativo según sea necesario\n      scaling: {\n        min: author.publications.length * 10, // Ajuste el tamaño mínimo según sea necesario\n        max: author.publications.length * 15 // Ajuste el tamaño máximo según sea necesario\n      },\n      font: {\n        size: Math.floor(author.publications.length * 1.5), // Ajuste el tamaño de la fuente según sea necesario\n        color: \"#ffffff\"\n      },\n      color: {\n        background: \"rgb(0, 22, 68)\",\n        border: \"#000000\",\n        highlight: {\n          background: \"#00ff00\",\n          border: \"#000000\"\n        },\n        hover: {\n          background: \"#0000ff\",\n          border: \"#000000\"\n        }\n      },\n      x: (author.researcher === authorWithMostPublications.researcher) ? 0 : undefined, // Centro al autor con más publicaciones\n      y: (author.researcher === authorWithMostPublications.researcher) ? 0 : undefined, // Centro al autor con más publicaciones\n      level: (author.researcher === authorWithMostPublications.researcher) ? 0 : distances[author.researcher] / maxDistance // Calcular el nivel según la distancia\n    }));\n\n    const nodes: DataSet<Node> = new DataSet(nodesData);\n    return nodes;\n  }\n  getEdges(): DataSet<Edge> {\n    // Ordenar los autores por el número de publicaciones en orden descendente\n    const sortedAuthors = this.nameAuthors.sort((a: { publications: string | any[]; }, b: { publications: string | any[]; }) => b.publications.length - a.publications.length);\n  \n    // Tomar al primer autor de la lista, que será el autor con más publicaciones\n    const authorWithMostPublications = sortedAuthors[0];\n  \n    // Generar aristas conectando al autor con más publicaciones con todos los demás autores\n    const edgesData: Edge[] = this.nameAuthors.filter((author: { researcher: any; }) =>\n      author.researcher !== authorWithMostPublications.researcher\n    ).map((author: { researcher: any; }) =>\n      ({ from: authorWithMostPublications.researcher, to: author.researcher })\n    );\n  \n    const edges: DataSet<Edge> = new DataSet(edgesData);\n    return edges;\n  }\n  \n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
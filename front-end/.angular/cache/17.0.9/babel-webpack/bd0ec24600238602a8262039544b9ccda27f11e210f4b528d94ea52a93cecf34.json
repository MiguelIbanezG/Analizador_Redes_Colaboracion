{"ast":null,"code":"import { DataSet } from 'vis';\nimport { v4 as uuidv4 } from 'uuid';\nimport * as i0 from \"@angular/core\";\nexport class NetworkInitService {\n  constructor() {\n    this.nameAuthors = [];\n    this.showCluster = true;\n    this.completeAuthors = [];\n    this.selectedAuthors = [];\n    this.forggetAuthors = [];\n    this.groupedAuthors = {};\n    this.cluster = {\n      min: 1,\n      max: 100\n    };\n    this.ids = [];\n    this.distances = {};\n  }\n  // Función para generar un ID único\n  generateUniqueId() {\n    let id = uuidv4();\n    // Asegúrate de que el ID generado no está duplicado\n    while (this.ids.some(item => item.id === id)) {\n      id = uuidv4();\n    }\n    return id;\n  }\n  // Function to create Nodes\n  getNodes() {\n    this.groupedAuthors = {};\n    this.nameAuthors = this.completeAuthors;\n    this.nameAuthors = this.nameAuthors.map(author => {\n      let researcher = author.researcher;\n      researcher = researcher.replace(/&aacute;/g, 'á').replace(/&eacute;/g, 'é').replace(/&iacute;/g, 'í').replace(/&oacute;/g, 'ó').replace(/&uacute;/g, 'ú').replace(/&ntilde;/g, 'ñ').replace(/&Aacute;/g, 'Á').replace(/&Eacute;/g, 'É').replace(/&Iacute;/g, 'Í').replace(/&Oacute;/g, 'Ó').replace(/&Uacute;/g, 'Ú').replace(/&Ntilde;/g, 'Ñ').replace(/&agrave;/g, 'à').replace(/&egrave;/g, 'è').replace(/&ograve;/g, 'ò').replace(/&Agrave;/g, 'À').replace(/&Egrave;/g, 'È').replace(/&Ograve;/g, 'Ò').replace(/&acirc;/g, 'â').replace(/&Acirc;/g, 'Â').replace(/&atilde;/g, 'ã').replace(/&Atilde;/g, 'Ã').replace(/&ouml;/g, 'ö').replace(/&Ouml;/g, 'Ö');\n      author.researcher = researcher;\n      return author;\n    });\n    // Group authors by the number of publications less than cluster.min\n    this.nameAuthors.forEach(author => {\n      if ((author.publications.length < this.cluster.min || author.publications.length > this.cluster.max) && author.researcher != this.selectedAuthors[0]) {\n        const publicationCount = author.publications.length.toString();\n        if (!this.groupedAuthors[publicationCount]) {\n          this.groupedAuthors[publicationCount] = [];\n        }\n        this.groupedAuthors[publicationCount].push(author.researcher);\n      }\n    });\n    this.nameAuthors = this.nameAuthors.filter(author => author.publications.length >= this.cluster.min && author.publications.length <= this.cluster.max || author.researcher == this.selectedAuthors[0]);\n    if (this.showCluster == true) {\n      // Create new authors for each group\n      Object.keys(this.groupedAuthors).forEach(publicationCount => {\n        const authors = this.groupedAuthors[publicationCount];\n        const count = parseInt(publicationCount);\n        const publications = [];\n        for (let i = 0; i < count; i++) {\n          publications.push(\"aaa\");\n        }\n        const newAuthor = {\n          researcher: authors.length.toString(),\n          publications: publications\n        };\n        this.nameAuthors.push(newAuthor);\n      });\n    }\n    var authorWithMostPublications;\n    var authorWithLeastPublications;\n    if (this.nameAuthors.length != 0) {\n      authorWithMostPublications = this.nameAuthors.reduce((prevAuthor, currentAuthor) => {\n        if (currentAuthor.researcher !== this.selectedAuthors[0]) {\n          if (!prevAuthor || currentAuthor.publications.length > prevAuthor.publications.length) {\n            return currentAuthor;\n          }\n        }\n        return prevAuthor;\n      }, null);\n      authorWithLeastPublications = this.nameAuthors.reduce((prevAuthor, currentAuthor) => {\n        return prevAuthor.publications.length < currentAuthor.publications.length ? prevAuthor : currentAuthor;\n      });\n      const maxPublications = authorWithMostPublications.publications.length;\n      const minPublications = authorWithLeastPublications.publications.length;\n      this.nameAuthors.forEach(author => {\n        if (author.researcher != this.selectedAuthors[0]) {\n          if (maxPublications == minPublications) {\n            this.distances[author.researcher] = 250;\n          } else {\n            const proportion = (maxPublications - author.publications.length) / (maxPublications - minPublications);\n            const distance = (Math.pow(proportion, 4) * 300 + 400) * 4;\n            this.distances[author.researcher] = distance;\n          }\n        }\n      });\n    }\n    const sortedAuthors = this.nameAuthors.slice().sort((a, b) => {\n      return a.publications.length - b.publications.length;\n    });\n    const totalAuthors = sortedAuthors.length;\n    const angleStep = Math.PI * 2 / totalAuthors;\n    let currentAngle = 0;\n    const nodesData = sortedAuthors.map(author => {\n      let nodeSize = Math.floor(author.publications.length * 4) + 60;\n      if (author.researcher === this.selectedAuthors[0]) {\n        nodeSize = nodeSize + 50;\n      }\n      if (nodeSize > 200) {\n        nodeSize = 200;\n      }\n      var distanceFromCenter = 0;\n      if (this.selectedAuthors[0] != author.researcher) {\n        var distanceFromCenter = this.distances[author.researcher];\n        var x = Math.cos(currentAngle) * distanceFromCenter;\n        var y = Math.sin(currentAngle) * distanceFromCenter;\n        currentAngle += angleStep;\n        const id = this.generateUniqueId();\n        this.ids.push({\n          name: author.researcher,\n          id: id\n        });\n        return {\n          id: id,\n          label: author.researcher,\n          font: {\n            size: nodeSize,\n            color: \"#ffffff\"\n          },\n          x: x,\n          y: y\n        };\n      } else {\n        return {\n          id: author.researcher,\n          label: author.researcher,\n          font: {\n            size: nodeSize,\n            color: \"#ffffff\"\n          },\n          x: 0,\n          y: 0\n        };\n      }\n    });\n    const nodes = new DataSet(nodesData);\n    return nodes;\n  }\n  // Function to create Edges\n  getEdges() {\n    console.log(this.nameAuthors);\n    console.log(this.completeAuthors);\n    const edgesData = this.nameAuthors.filter(author => author.researcher !== this.selectedAuthors[0]).map(author => {\n      var Fid;\n      this.ids.forEach(ident => {\n        if (ident.name = author.researcher) {\n          Fid = ident.id;\n        }\n      });\n      const numPublications = author.publications.length.toString();\n      return {\n        from: this.selectedAuthors[0],\n        to: Fid,\n        label: numPublications\n      };\n    });\n    this.nameAuthors = this.nameAuthors.filter(author => isNaN(Number(author.researcher)));\n    if (this.showCluster == true) {\n      Object.keys(this.groupedAuthors).forEach(publicationCount => {\n        const authors = this.groupedAuthors[publicationCount];\n        const newAuthor = {\n          researcher: authors.length.toString(),\n          publications: authors\n        };\n        this.nameAuthors.push(newAuthor);\n      });\n    }\n    const edges = new DataSet(edgesData);\n    return edges;\n  }\n  getClusterMin() {\n    return this.cluster.min;\n  }\n  setClusterMin(value) {\n    this.cluster.min = value;\n  }\n  getClusterMax() {\n    return this.cluster.max;\n  }\n  setClusterMax(value) {\n    this.cluster.max = value;\n  }\n  static #_ = this.ɵfac = function NetworkInitService_Factory(t) {\n    return new (t || NetworkInitService)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: NetworkInitService,\n    factory: NetworkInitService.ɵfac\n  });\n}","map":{"version":3,"names":["DataSet","v4","uuidv4","NetworkInitService","constructor","nameAuthors","showCluster","completeAuthors","selectedAuthors","forggetAuthors","groupedAuthors","cluster","min","max","ids","distances","generateUniqueId","id","some","item","getNodes","map","author","researcher","replace","forEach","publications","length","publicationCount","toString","push","filter","Object","keys","authors","count","parseInt","i","newAuthor","authorWithMostPublications","authorWithLeastPublications","reduce","prevAuthor","currentAuthor","maxPublications","minPublications","proportion","distance","Math","pow","sortedAuthors","slice","sort","a","b","totalAuthors","angleStep","PI","currentAngle","nodesData","nodeSize","floor","distanceFromCenter","x","cos","y","sin","name","label","font","size","color","nodes","getEdges","console","log","edgesData","Fid","ident","numPublications","from","to","isNaN","Number","edges","getClusterMin","setClusterMin","value","getClusterMax","setClusterMax","_","_2","factory","ɵfac"],"sources":["/home/miguel/Collaboration_Networks/front-end/src/app/services/network.init.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { DataSet, Edge } from 'vis';\nimport { Node } from '../models/network.model';\nimport { v4 as uuidv4 } from 'uuid';\n\n\n@Injectable()\nexport class NetworkInitService {\n\n  public nameAuthors:any = [];\n  public showCluster = true;\n  public completeAuthors:any = [];\n  public selectedAuthors:any = [];\n  public forggetAuthors:any = [];\n  public groupedAuthors:{ [key: string]: string[] } = {};\n  public cluster: { min: number, max: number} =  { min: 1, max: 100}\n  private ids: { name: string, id: string}[] = [];\n  private distances: { [key: string]: number } = {};\n\n  // Función para generar un ID único\n  generateUniqueId(): string {\n    let id = uuidv4();\n    // Asegúrate de que el ID generado no está duplicado\n    while (this.ids.some(item => item.id === id)) {\n      id = uuidv4();\n    }\n    return id;\n  }\n\n\n  // Function to create Nodes\n  getNodes(): DataSet<Node> {\n\n    this.groupedAuthors = {};\n    this.nameAuthors = this.completeAuthors;\n\n    this.nameAuthors = this.nameAuthors.map((author: any) => {\n      let researcher = author.researcher; \n  \n      researcher = researcher.replace(/&aacute;/g, 'á')\n          .replace(/&eacute;/g, 'é')\n          .replace(/&iacute;/g, 'í')\n          .replace(/&oacute;/g, 'ó')\n          .replace(/&uacute;/g, 'ú')\n          .replace(/&ntilde;/g, 'ñ')\n          .replace(/&Aacute;/g, 'Á')\n          .replace(/&Eacute;/g, 'É')\n          .replace(/&Iacute;/g, 'Í')\n          .replace(/&Oacute;/g, 'Ó')\n          .replace(/&Uacute;/g, 'Ú')\n          .replace(/&Ntilde;/g, 'Ñ')\n          .replace(/&agrave;/g, 'à')\n          .replace(/&egrave;/g, 'è')\n          .replace(/&ograve;/g, 'ò')\n          .replace(/&Agrave;/g, 'À')\n          .replace(/&Egrave;/g, 'È')\n          .replace(/&Ograve;/g, 'Ò')\n          .replace(/&acirc;/g, 'â')\n          .replace(/&Acirc;/g, 'Â')\n          .replace(/&atilde;/g, 'ã')\n          .replace(/&Atilde;/g, 'Ã')\n          .replace(/&ouml;/g, 'ö')\n          .replace(/&Ouml;/g, 'Ö');\n  \n      author.researcher = researcher;\n  \n      return author;\n    });\n    \n    // Group authors by the number of publications less than cluster.min\n\n    this.nameAuthors.forEach((author: { publications: string | any[]; researcher: string; }) => {\n        if ((author.publications.length < this.cluster.min || author.publications.length > this.cluster.max) && author.researcher != this.selectedAuthors[0]) {\n            const publicationCount = author.publications.length.toString();\n            if (!this.groupedAuthors[publicationCount]) {\n              this.groupedAuthors[publicationCount] = [];\n            }\n            this.groupedAuthors[publicationCount].push(author.researcher);\n        }\n    });\n\n    this.nameAuthors = this.nameAuthors.filter((author: { publications: string[]; researcher: boolean; }) => \n      (author.publications.length >= this.cluster.min && author.publications.length <= this.cluster.max) || \n      author.researcher == this.selectedAuthors[0]\n    );\n\n    if( this.showCluster == true){\n\n      // Create new authors for each group\n      Object.keys(this.groupedAuthors).forEach(publicationCount => {\n        const authors = this.groupedAuthors[publicationCount];\n        const count = parseInt(publicationCount);\n        const publications = [];\n        for (let i = 0; i < count; i++) {\n            publications.push(\"aaa\");\n        }\n        const newAuthor = { researcher: authors.length.toString(), publications: publications };\n        \n        this.nameAuthors.push(newAuthor);\n      });\n  \n    }\n\n    var authorWithMostPublications;\n    var authorWithLeastPublications;\n\n    if (this.nameAuthors.length != 0) {\n\n      authorWithMostPublications = this.nameAuthors.reduce((prevAuthor: any, currentAuthor: any) => {\n        if (currentAuthor.researcher !== this.selectedAuthors[0]) {\n            if (!prevAuthor || currentAuthor.publications.length > prevAuthor.publications.length) {\n                return currentAuthor;\n            }\n        }\n        return prevAuthor;\n      }, null);\n  \n      authorWithLeastPublications = this.nameAuthors.reduce((prevAuthor: { publications: string | any[]; }, currentAuthor: { publications: string | any[]; }) => {\n        return (prevAuthor.publications.length < currentAuthor.publications.length) ? prevAuthor : currentAuthor;\n      });\n\n\n      const maxPublications = authorWithMostPublications.publications.length;\n      const minPublications = authorWithLeastPublications.publications.length;\n\n\n      this.nameAuthors.forEach((author: any) => {\n          if (author.researcher != this.selectedAuthors[0]) {\n              if(maxPublications == minPublications){ \n                this.distances[author.researcher] = 250;\n              } else{\n                const proportion = (maxPublications - author.publications.length) / (maxPublications - minPublications);\n                const distance = (Math.pow(proportion, 4) * 300 + 400) * 4; \n                this.distances[author.researcher] = distance;\n              }\n          }\n      });\n\n    }\n\n\n    const sortedAuthors = this.nameAuthors.slice().sort((a: any, b: any) => {\n      return a.publications.length - b.publications.length;\n    });\n\n    const totalAuthors = sortedAuthors.length;\n    const angleStep = (Math.PI * 2) / totalAuthors;\n    let currentAngle = 0;\n\n    const nodesData: Node[] = sortedAuthors.map((author: any) => {\n\n      let nodeSize = Math.floor(author.publications.length * 4) + 60;\n\n      if (author.researcher === this.selectedAuthors[0]) {\n        nodeSize = nodeSize + 50; \n      }\n      if(nodeSize > 200){\n        nodeSize = 200\n      }\n\n\n      var distanceFromCenter = 0;\n\n      if(this.selectedAuthors[0] != author.researcher){\n\n        var distanceFromCenter = this.distances[author.researcher];\n\n        var x = Math.cos(currentAngle) * distanceFromCenter ;\n        var y = Math.sin(currentAngle) * distanceFromCenter ;\n\n        currentAngle += angleStep;\n\n        const id = this.generateUniqueId();\n        this.ids.push({ name: author.researcher, id: id });\n  \n        return {\n          id: id,\n          label: author.researcher,\n          font: {\n            size: nodeSize,\n            color: \"#ffffff\"\n          },\n          x: x,\n          y: y\n        };\n\n\n      } else{\n\n        return {\n          id: author.researcher,\n          label: author.researcher,\n          font: {\n            size: nodeSize,\n            color: \"#ffffff\"\n          },\n          x: 0,\n          y: 0\n        };\n      }\n \n    });\n\n    const nodes: DataSet<Node> = new DataSet(nodesData);\n    return nodes;\n  }\n\n  // Function to create Edges\n  getEdges(): DataSet<Edge> {\n\n    console.log(this.nameAuthors)\n    console.log(this.completeAuthors)\n\n    const edgesData: Edge[] = this.nameAuthors\n    .filter((author: { researcher: any; }) => author.researcher !== this.selectedAuthors[0])\n    .map((author: { publications: string | any[]; researcher: any; }) => {\n\n      var Fid;\n\n      this.ids.forEach(ident => {\n\n        if(ident.name = author.researcher){\n          Fid = ident.id;\n        }\n        \n      });\n\n      const numPublications = author.publications.length.toString();\n      return { from: this.selectedAuthors[0], to: Fid, label: numPublications };\n    });\n\n    this.nameAuthors = this.nameAuthors.filter((author: { researcher: string; }) => isNaN(Number(author.researcher)));\n\n    if(this.showCluster == true ){\n\n      Object.keys(this.groupedAuthors).forEach(publicationCount => {\n        const authors = this.groupedAuthors[publicationCount];\n        const newAuthor = { researcher: authors.length.toString(), publications: authors };    \n        this.nameAuthors.push(newAuthor);\n      });\n\n    }\n\n\n    const edges: DataSet<Edge> = new DataSet(edgesData);\n    return edges;\n\n\n  }\n\n  getClusterMin(): number {\n    return this.cluster.min;\n  }\n\n  setClusterMin(value: number): void {\n    this.cluster.min = value;\n  }\n\n  getClusterMax(): number {\n    return this.cluster.max;\n  }\n\n  setClusterMax(value: number): void {\n    this.cluster.max = value;\n  }\n  \n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
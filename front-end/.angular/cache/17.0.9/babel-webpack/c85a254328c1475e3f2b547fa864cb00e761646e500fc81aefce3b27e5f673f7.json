{"ast":null,"code":"import { DataSet } from 'vis';\nimport * as i0 from \"@angular/core\";\nexport class AppNetworkInitService {\n  constructor() {\n    this.nameAuthors = [];\n  }\n  getNodes() {\n    console.log(this.nameAuthors);\n    this.nameAuthors = this.nameAuthors.map(author => {\n      if (typeof author === 'string') {\n        // Reemplazar caracteres especiales\n        author = author.replace(/&aacute;/g, 'á').replace(/&eacute;/g, 'é').replace(/&iacute;/g, 'í').replace(/&oacute;/g, 'ó').replace(/&uacute;/g, 'ú').replace(/&ntilde;/g, 'ñ').replace(/&Aacute;/g, 'Á').replace(/&Eacute;/g, 'É').replace(/&Iacute;/g, 'Í').replace(/&Oacute;/g, 'Ó').replace(/&Uacute;/g, 'Ú').replace(/&Ntilde;/g, 'Ñ').replace(/&agrave;/g, 'à').replace(/&egrave;/g, 'è').replace(/&ograve;/g, 'ò').replace(/&Agrave;/g, 'À').replace(/&Egrave;/g, 'È').replace(/&Ograve;/g, 'Ò').replace(/&acirc;/g, 'â').replace(/&Acirc;/g, 'Â').replace(/&atilde;/g, 'ã').replace(/&Atilde;/g, 'Ã').replace(/&ouml;/g, 'ö').replace(/&Ouml;/g, 'Ö');\n      }\n      return author;\n    });\n    console.log(this.nameAuthors);\n    // Obtener al autor con más publicaciones\n    const authorWithMostPublications = this.nameAuthors.reduce((prev, current) => prev.publications.length > current.publications.length ? prev : current);\n    const distances = {};\n    this.nameAuthors.forEach(author => {\n      const distance = author === authorWithMostPublications ? 0 : 500 / author.publications.length;\n      distances[author.researcher] = distance;\n    });\n    // Mapear los nodos ajustando el tamaño en función de las publicaciones y la distancia al autor principal\n    const nodesData = this.nameAuthors.map(author => {\n      var distanceFromCenter = distances[author.researcher] * 5;\n      const angle = Math.random() * Math.PI * 2;\n      if (distanceFromCenter > 2000) {\n        distanceFromCenter = distanceFromCenter - 1750;\n      } else if (distanceFromCenter > 1500) {\n        distanceFromCenter = distanceFromCenter - 1100;\n      } else if (distanceFromCenter > 1000) {\n        distanceFromCenter = distanceFromCenter - 750;\n      } else if (distanceFromCenter > 500) {\n        distanceFromCenter = distanceFromCenter - 200;\n      } else if (distanceFromCenter < 100 && distanceFromCenter != 0) {\n        distanceFromCenter = distanceFromCenter + 100;\n      }\n      const x = Math.cos(angle) * distanceFromCenter;\n      const y = Math.sin(angle) * distanceFromCenter;\n      return {\n        id: author.researcher,\n        label: author.researcher,\n        font: {\n          size: Math.floor(author.publications.length) + 12,\n          color: \"#ffffff\"\n        },\n        x: x,\n        y: y\n      };\n    });\n    const nodes = new DataSet(nodesData);\n    return nodes;\n  }\n  getEdges() {\n    // Ordenar los autores por el número de publicaciones en orden descendente\n    const sortedAuthors = this.nameAuthors.sort((a, b) => b.publications.length - a.publications.length);\n    // Tomar al primer autor de la lista, que será el autor con más publicaciones\n    const authorWithMostPublications = sortedAuthors[0];\n    // Generar aristas conectando al autor con más publicaciones con todos los demás autores\n    const edgesData = this.nameAuthors.filter(author => author.researcher !== authorWithMostPublications.researcher).map(author => ({\n      from: authorWithMostPublications.researcher,\n      to: author.researcher\n    }));\n    const edges = new DataSet(edgesData);\n    return edges;\n  }\n  static #_ = this.ɵfac = function AppNetworkInitService_Factory(t) {\n    return new (t || AppNetworkInitService)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AppNetworkInitService,\n    factory: AppNetworkInitService.ɵfac\n  });\n}","map":{"version":3,"names":["DataSet","AppNetworkInitService","constructor","nameAuthors","getNodes","console","log","map","author","replace","authorWithMostPublications","reduce","prev","current","publications","length","distances","forEach","distance","researcher","nodesData","distanceFromCenter","angle","Math","random","PI","x","cos","y","sin","id","label","font","size","floor","color","nodes","getEdges","sortedAuthors","sort","a","b","edgesData","filter","from","to","edges","_","_2","factory","ɵfac"],"sources":["/home/miguel/Analizador_Redes_Colaboracion/interfaz/src/app/services/network.init.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Network, DataSet, Options, Data, IdType, Edge } from 'vis';\nimport { Node } from '../models/network.model';\n@Injectable()\nexport class AppNetworkInitService {\n\n  public nameAuthors:any = [];\n\n  getNodes(): DataSet<Node> {\n    \n    console.log(this.nameAuthors)\n    \n    this.nameAuthors = this.nameAuthors.map((author: any) => {\n      if (typeof author === 'string') {\n        // Reemplazar caracteres especiales\n        author = author.replace(/&aacute;/g, 'á')\n          .replace(/&eacute;/g, 'é')\n          .replace(/&iacute;/g, 'í')\n          .replace(/&oacute;/g, 'ó')\n          .replace(/&uacute;/g, 'ú')\n          .replace(/&ntilde;/g, 'ñ')\n          .replace(/&Aacute;/g, 'Á')\n          .replace(/&Eacute;/g, 'É')\n          .replace(/&Iacute;/g, 'Í')\n          .replace(/&Oacute;/g, 'Ó')\n          .replace(/&Uacute;/g, 'Ú')\n          .replace(/&Ntilde;/g, 'Ñ')\n          .replace(/&agrave;/g, 'à')\n          .replace(/&egrave;/g, 'è')\n          .replace(/&ograve;/g, 'ò')\n          .replace(/&Agrave;/g, 'À')\n          .replace(/&Egrave;/g, 'È')\n          .replace(/&Ograve;/g, 'Ò')\n          .replace(/&acirc;/g, 'â')\n          .replace(/&Acirc;/g, 'Â')\n          .replace(/&atilde;/g, 'ã')\n          .replace(/&Atilde;/g, 'Ã')\n          .replace(/&ouml;/g, 'ö')\n          .replace(/&Ouml;/g, 'Ö');\n      }\n      return author;\n    });\n\n    console.log(this.nameAuthors)\n\n    // Obtener al autor con más publicaciones\n    const authorWithMostPublications = this.nameAuthors.reduce((prev: any, current: any) => (prev.publications.length > current.publications.length) ? prev : current);\n\n    const distances: { [key: string]: number } = {};\n    this.nameAuthors.forEach((author: any) => {\n      const distance = author === authorWithMostPublications ? 0 : 500 / author.publications.length ;\n      distances[author.researcher] = distance;\n\n    });\n\n    // Mapear los nodos ajustando el tamaño en función de las publicaciones y la distancia al autor principal\n    const nodesData: Node[] = this.nameAuthors.map((author: any) => {\n      var distanceFromCenter = distances[author.researcher] * 5\n      const angle = Math.random() * Math.PI * 2;\n\n      if(distanceFromCenter > 2000 ){\n        distanceFromCenter =  distanceFromCenter - 1750;\n      }\n      else if(distanceFromCenter > 1500 ){\n        distanceFromCenter =  distanceFromCenter - 1100;\n      }\n      else if(distanceFromCenter > 1000 ){\n        distanceFromCenter =  distanceFromCenter - 750;\n      }\n      else if(distanceFromCenter > 500 ){\n        distanceFromCenter =  distanceFromCenter - 200;\n      }\n      else if(distanceFromCenter < 100 && distanceFromCenter != 0){\n        distanceFromCenter = distanceFromCenter + 100;\n      }\n      const x = Math.cos(angle) * distanceFromCenter;\n      const y = Math.sin(angle) * distanceFromCenter;\n      return {\n        id: author.researcher,\n        label: author.researcher,\n        font: {\n          size: Math.floor(author.publications.length) + 12, // Tamaño de fuente ajustado\n          color: \"#ffffff\"\n        },\n        x: x,\n        y: y\n      };\n    });\n\n    const nodes: DataSet<Node> = new DataSet(nodesData);\n    return nodes;\n  }\n\n\n  getEdges(): DataSet<Edge> {\n    // Ordenar los autores por el número de publicaciones en orden descendente\n    const sortedAuthors = this.nameAuthors.sort((a: { publications: string | any[]; }, b: { publications: string | any[]; }) => b.publications.length - a.publications.length);\n  \n    // Tomar al primer autor de la lista, que será el autor con más publicaciones\n    const authorWithMostPublications = sortedAuthors[0];\n  \n    // Generar aristas conectando al autor con más publicaciones con todos los demás autores\n    const edgesData: Edge[] = this.nameAuthors.filter((author: { researcher: any; }) =>\n      author.researcher !== authorWithMostPublications.researcher\n    ).map((author: { researcher: any; }) =>\n      ({ from: authorWithMostPublications.researcher, to: author.researcher })\n    );\n  \n    const edges: DataSet<Edge> = new DataSet(edgesData);\n    return edges;\n  }\n  \n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
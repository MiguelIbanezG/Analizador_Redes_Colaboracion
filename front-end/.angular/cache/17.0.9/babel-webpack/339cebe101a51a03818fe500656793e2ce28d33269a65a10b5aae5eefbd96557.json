{"ast":null,"code":"import { DataSet } from 'vis';\nimport * as i0 from \"@angular/core\";\nexport class AppNetworkInitService {\n  constructor() {\n    this.nameAuthors = [];\n    this.selectedAuthors = [];\n    this.cluster = {\n      min: 2,\n      max: 'someValue'\n    };\n  }\n  // Function to create Nodes\n  getNodes() {\n    let totalRemovedAuthors = 0;\n    const removedAuthorsMap = new Map();\n    // Eliminar autores con menos publicaciones que cluster.min y registrar la cantidad de publicaciones eliminadas para cada número de publicaciones\n    this.nameAuthors = this.nameAuthors.filter(author => {\n      if (author.publications < this.cluster.min) {\n        const removedPublications = author.publications;\n        if (removedAuthorsMap.has(removedPublications)) {\n          removedAuthorsMap.set(removedPublications, removedAuthorsMap.get(removedPublications) + 1);\n        } else {\n          removedAuthorsMap.set(removedPublications, 1);\n        }\n        return false; // eliminar el autor\n      }\n\n      return true; // mantener el autor\n    });\n    // Crear un nuevo autor por cada número distinto de publicaciones eliminadas\n    removedAuthorsMap.forEach((numAuthors, numPublications) => {\n      const newAuthor = {\n        name: numAuthors.toString(),\n        publications: numPublications\n      };\n      this.nameAuthors.push(newAuthor);\n    });\n    this.nameAuthors = this.nameAuthors.map(author => {\n      let researcher = author.researcher;\n      researcher = researcher.replace(/&aacute;/g, 'á').replace(/&eacute;/g, 'é').replace(/&iacute;/g, 'í').replace(/&oacute;/g, 'ó').replace(/&uacute;/g, 'ú').replace(/&ntilde;/g, 'ñ').replace(/&Aacute;/g, 'Á').replace(/&Eacute;/g, 'É').replace(/&Iacute;/g, 'Í').replace(/&Oacute;/g, 'Ó').replace(/&Uacute;/g, 'Ú').replace(/&Ntilde;/g, 'Ñ').replace(/&agrave;/g, 'à').replace(/&egrave;/g, 'è').replace(/&ograve;/g, 'ò').replace(/&Agrave;/g, 'À').replace(/&Egrave;/g, 'È').replace(/&Ograve;/g, 'Ò').replace(/&acirc;/g, 'â').replace(/&Acirc;/g, 'Â').replace(/&atilde;/g, 'ã').replace(/&Atilde;/g, 'Ã').replace(/&ouml;/g, 'ö').replace(/&Ouml;/g, 'Ö');\n      author.researcher = researcher;\n      return author;\n    });\n    const authorWithMostPublications = this.nameAuthors.reduce((prevAuthor, currentAuthor) => {\n      if (currentAuthor.researcher !== this.selectedAuthors[0]) {\n        if (!prevAuthor || currentAuthor.publications.length > prevAuthor.publications.length) {\n          return currentAuthor;\n        }\n      }\n      return prevAuthor;\n    }, null);\n    const authorWithLeastPublications = this.nameAuthors.reduce((prevAuthor, currentAuthor) => {\n      return prevAuthor.publications.length < currentAuthor.publications.length ? prevAuthor : currentAuthor;\n    });\n    const maxPublications = authorWithMostPublications.publications.length;\n    const minPublications = authorWithLeastPublications.publications.length;\n    let distances = {};\n    this.nameAuthors.forEach(author => {\n      if (author.researcher != this.selectedAuthors[0]) {\n        if (maxPublications == minPublications) {\n          distances[author.researcher] = 250;\n        } else {\n          const proportion = (maxPublications - author.publications.length) / (maxPublications - minPublications);\n          const distance = Math.pow(proportion, 4) * (500 - 220) + 220;\n          distances[author.researcher] = distance;\n        }\n      }\n    });\n    const sortedAuthors = this.nameAuthors.slice().sort((a, b) => {\n      return a.publications.length - b.publications.length;\n    });\n    const totalAuthors = sortedAuthors.length;\n    const angleStep = Math.PI * 2 / totalAuthors;\n    let currentAngle = 0;\n    const nodesData = sortedAuthors.map(author => {\n      let nodeSize = Math.floor(author.publications.length * 4) + 60;\n      if (author.researcher === this.selectedAuthors[0]) {\n        nodeSize = nodeSize + 50;\n      }\n      if (nodeSize > 200) {\n        nodeSize = 200;\n      }\n      var distanceFromCenter = 0;\n      if (this.selectedAuthors[0] != author.researcher) {\n        var distanceFromCenter = distances[author.researcher] * 5;\n      }\n      const x = Math.cos(currentAngle) * distanceFromCenter;\n      const y = Math.sin(currentAngle) * distanceFromCenter;\n      console.log(author.researcher);\n      console.log(x);\n      console.log(y);\n      currentAngle += angleStep;\n      console.log(currentAngle);\n      return {\n        id: author.researcher,\n        label: author.researcher,\n        font: {\n          size: nodeSize,\n          color: \"#ffffff\"\n        },\n        x: x,\n        y: y\n      };\n    });\n    const nodes = new DataSet(nodesData);\n    return nodes;\n  }\n  // Function to create Edges\n  getEdges() {\n    const edgesData = this.nameAuthors.filter(author => author.researcher !== this.selectedAuthors[0]).map(author => {\n      const numPublications = author.publications.length.toString();\n      return {\n        from: this.selectedAuthors[0],\n        to: author.researcher,\n        label: numPublications\n      };\n    });\n    const edges = new DataSet(edgesData);\n    return edges;\n  }\n  static #_ = this.ɵfac = function AppNetworkInitService_Factory(t) {\n    return new (t || AppNetworkInitService)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AppNetworkInitService,\n    factory: AppNetworkInitService.ɵfac\n  });\n}","map":{"version":3,"names":["DataSet","AppNetworkInitService","constructor","nameAuthors","selectedAuthors","cluster","min","max","getNodes","totalRemovedAuthors","removedAuthorsMap","Map","filter","author","publications","removedPublications","has","set","get","forEach","numAuthors","numPublications","newAuthor","name","toString","push","map","researcher","replace","authorWithMostPublications","reduce","prevAuthor","currentAuthor","length","authorWithLeastPublications","maxPublications","minPublications","distances","proportion","distance","Math","pow","sortedAuthors","slice","sort","a","b","totalAuthors","angleStep","PI","currentAngle","nodesData","nodeSize","floor","distanceFromCenter","x","cos","y","sin","console","log","id","label","font","size","color","nodes","getEdges","edgesData","from","to","edges","_","_2","factory","ɵfac"],"sources":["/home/miguel/Collaboration_Networks/front-end/src/app/services/network.init.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { DataSet, Edge } from 'vis';\nimport { Node } from '../models/network.model';\n\n@Injectable()\nexport class AppNetworkInitService {\n\n  \n\n  public nameAuthors:any = [];\n  public selectedAuthors:any = [];\n  private cluster: { min: number, max: string } = { min: 2, max: 'someValue' };\n\n  // Function to create Nodes\n  getNodes(): DataSet<Node> {\n\n    let totalRemovedAuthors = 0;\n    const removedAuthorsMap: Map<number, number> = new Map();\n\n    // Eliminar autores con menos publicaciones que cluster.min y registrar la cantidad de publicaciones eliminadas para cada número de publicaciones\n    this.nameAuthors = this.nameAuthors.filter((author: { publications: number; }) => {\n        if (author.publications < this.cluster.min) {\n            const removedPublications = author.publications;\n            if (removedAuthorsMap.has(removedPublications)) {\n                removedAuthorsMap.set(removedPublications, removedAuthorsMap.get(removedPublications)! + 1);\n            } else {\n                removedAuthorsMap.set(removedPublications, 1);\n            }\n            return false; // eliminar el autor\n        }\n        return true; // mantener el autor\n    });\n\n    // Crear un nuevo autor por cada número distinto de publicaciones eliminadas\n    removedAuthorsMap.forEach((numAuthors, numPublications) => {\n        const newAuthor = {\n            name: numAuthors.toString(),\n            publications: numPublications\n        };\n        this.nameAuthors.push(newAuthor);\n    });\n\n\n    this.nameAuthors = this.nameAuthors.map((author: any) => {\n      let researcher = author.researcher; \n  \n      researcher = researcher.replace(/&aacute;/g, 'á')\n          .replace(/&eacute;/g, 'é')\n          .replace(/&iacute;/g, 'í')\n          .replace(/&oacute;/g, 'ó')\n          .replace(/&uacute;/g, 'ú')\n          .replace(/&ntilde;/g, 'ñ')\n          .replace(/&Aacute;/g, 'Á')\n          .replace(/&Eacute;/g, 'É')\n          .replace(/&Iacute;/g, 'Í')\n          .replace(/&Oacute;/g, 'Ó')\n          .replace(/&Uacute;/g, 'Ú')\n          .replace(/&Ntilde;/g, 'Ñ')\n          .replace(/&agrave;/g, 'à')\n          .replace(/&egrave;/g, 'è')\n          .replace(/&ograve;/g, 'ò')\n          .replace(/&Agrave;/g, 'À')\n          .replace(/&Egrave;/g, 'È')\n          .replace(/&Ograve;/g, 'Ò')\n          .replace(/&acirc;/g, 'â')\n          .replace(/&Acirc;/g, 'Â')\n          .replace(/&atilde;/g, 'ã')\n          .replace(/&Atilde;/g, 'Ã')\n          .replace(/&ouml;/g, 'ö')\n          .replace(/&Ouml;/g, 'Ö');\n  \n      author.researcher = researcher;\n  \n      return author;\n    });\n\n    const authorWithMostPublications = this.nameAuthors.reduce((prevAuthor: any, currentAuthor: any) => {\n      if (currentAuthor.researcher !== this.selectedAuthors[0]) {\n          if (!prevAuthor || currentAuthor.publications.length > prevAuthor.publications.length) {\n              return currentAuthor;\n          }\n      }\n      return prevAuthor;\n    }, null);\n\n    const authorWithLeastPublications = this.nameAuthors.reduce((prevAuthor: { publications: string | any[]; }, currentAuthor: { publications: string | any[]; }) => {\n      return (prevAuthor.publications.length < currentAuthor.publications.length) ? prevAuthor : currentAuthor;\n    });\n\n    const maxPublications = authorWithMostPublications.publications.length;\n    const minPublications = authorWithLeastPublications.publications.length;\n\n    let distances: { [key: string]: number } = {};\n    this.nameAuthors.forEach((author: any) => {\n        if (author.researcher != this.selectedAuthors[0]) {\n            if(maxPublications == minPublications){ \n              distances[author.researcher] = 250;\n            } else{\n              const proportion = (maxPublications - author.publications.length) / (maxPublications - minPublications);\n              const distance = Math.pow(proportion, 4) * (500 - 220) + 220; \n              distances[author.researcher] = distance;\n            }\n        }\n    });\n\n    const sortedAuthors = this.nameAuthors.slice().sort((a: any, b: any) => {\n      return a.publications.length - b.publications.length;\n    });\n\n    const totalAuthors = sortedAuthors.length;\n    const angleStep = (Math.PI * 2) / totalAuthors;\n    let currentAngle = 0;\n\n    const nodesData: Node[] = sortedAuthors.map((author: any) => {\n\n      let nodeSize = Math.floor(author.publications.length * 4) + 60;\n   \n\n      if (author.researcher === this.selectedAuthors[0]) {\n          nodeSize = nodeSize + 50; \n      }\n      if(nodeSize > 200){\n        nodeSize = 200\n      }\n\n      var distanceFromCenter = 0;\n\n      if(this.selectedAuthors[0] != author.researcher){\n        var distanceFromCenter = distances[author.researcher] * 5\n      } \n    \n      const x = Math.cos(currentAngle) * distanceFromCenter;\n      const y = Math.sin(currentAngle) * distanceFromCenter;\n      console.log(author.researcher)\n      console.log(x)\n      console.log(y)\n      currentAngle += angleStep;\n      console.log(currentAngle)\n      return {\n        id: author.researcher,\n        label: author.researcher,\n        font: {\n          size: nodeSize,\n          color: \"#ffffff\"\n        },\n        x: x,\n        y: y\n      };\n    });\n\n    const nodes: DataSet<Node> = new DataSet(nodesData);\n    return nodes;\n  }\n\n  // Function to create Edges\n  getEdges(): DataSet<Edge> {\n\n    const edgesData: Edge[] = this.nameAuthors\n    .filter((author: { researcher: any; }) => author.researcher !== this.selectedAuthors[0])\n    .map((author: { publications: string | any[]; researcher: any; }) => {\n      const numPublications = author.publications.length.toString();\n      return { from: this.selectedAuthors[0], to: author.researcher, label: numPublications };\n    });\n\n    const edges: DataSet<Edge> = new DataSet(edgesData);\n    return edges;\n}\n  \n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}